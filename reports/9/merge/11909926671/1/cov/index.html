
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cmd: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/shiron-dev/dotfiles/scripts/dofy/cmd/main.go (0.0%)</option>
				
				<option value="file1">github.com/shiron-dev/dotfiles/scripts/dofy/internal/adapter/controller/main.go (0.0%)</option>
				
				<option value="file2">github.com/shiron-dev/dotfiles/scripts/dofy/internal/di/wire_gen.go (40.9%)</option>
				
				<option value="file3">github.com/shiron-dev/dotfiles/scripts/dofy/internal/domain/brewbundle.go (81.2%)</option>
				
				<option value="file4">github.com/shiron-dev/dotfiles/scripts/dofy/internal/domain/mdprint.go (0.0%)</option>
				
				<option value="file5">github.com/shiron-dev/dotfiles/scripts/dofy/internal/infrastructure/brew.go (84.6%)</option>
				
				<option value="file6">github.com/shiron-dev/dotfiles/scripts/dofy/internal/infrastructure/config.go (80.0%)</option>
				
				<option value="file7">github.com/shiron-dev/dotfiles/scripts/dofy/internal/infrastructure/deps.go (37.5%)</option>
				
				<option value="file8">github.com/shiron-dev/dotfiles/scripts/dofy/internal/infrastructure/file.go (100.0%)</option>
				
				<option value="file9">github.com/shiron-dev/dotfiles/scripts/dofy/internal/infrastructure/git.go (100.0%)</option>
				
				<option value="file10">github.com/shiron-dev/dotfiles/scripts/dofy/internal/infrastructure/printout.go (100.0%)</option>
				
				<option value="file11">github.com/shiron-dev/dotfiles/scripts/dofy/internal/test/util/git.go (78.3%)</option>
				
				<option value="file12">github.com/shiron-dev/dotfiles/scripts/dofy/internal/test/util/util.go (88.9%)</option>
				
				<option value="file13">github.com/shiron-dev/dotfiles/scripts/dofy/internal/usecase/brew.go (0.0%)</option>
				
				<option value="file14">github.com/shiron-dev/dotfiles/scripts/dofy/internal/usecase/config.go (0.0%)</option>
				
				<option value="file15">github.com/shiron-dev/dotfiles/scripts/dofy/internal/usecase/deps.go (0.0%)</option>
				
				<option value="file16">github.com/shiron-dev/dotfiles/scripts/dofy/internal/usecase/printout.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "os"

        "github.com/shiron-dev/dotfiles/scripts/dofy/internal/di"
)

func main() <span class="cov0" title="0">{
        controllerSet, err := di.InitializeControllerSet(os.Stdout, os.Stderr)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">dofyController := controllerSet.DofyController
        dofyController.Start()</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package controller

import (
        "bufio"
        "context"
        "os"
        "strings"

        "github.com/shiron-dev/dotfiles/scripts/dofy/internal/usecase"
)

type DofyController interface {
        Start()
        getMode() string
}

type DofyControllerImpl struct {
        printoutUC usecase.PrintOutUsecase
        configUC   usecase.ConfigUsecase
        depsUC     usecase.DepsUsecase
}

func NewDofyController(
        printoutUC usecase.PrintOutUsecase,
        configUC usecase.ConfigUsecase,
        depsUC usecase.DepsUsecase,
) *DofyControllerImpl <span class="cov0" title="0">{
        return &amp;DofyControllerImpl{
                printoutUC: printoutUC,
                configUC:   configUC,
                depsUC:     depsUC,
        }
}</span>

func (c *DofyControllerImpl) Start() <span class="cov0" title="0">{
        logfile := c.printoutUC.SetLogOutput()
        defer logfile.Close()

        c.printoutUC.PrintMdf(`

# shiron-dev dotfiles setup script

This script will install dependencies and setup dotfiles.

`)

        c.printoutUC.PrintMdf(`
## Load environment information

### Environment information
`)

        if envInfo, err := c.configUC.ScanEnvInfo(); err == nil </span><span class="cov0" title="0">{
                c.printoutUC.PrintObj(*envInfo)
        }</span> else<span class="cov0" title="0"> {
                panic(err)</span>
        }

        <span class="cov0" title="0">c.printoutUC.PrintMdf(`
### Setup mode
`)

        mode := c.getMode()

        c.printoutUC.PrintMdf("Start setup in `" + mode + "` mode.")

        initialSetupFlag := !c.depsUC.CheckInstalled("brew")

        err := c.depsUC.InstallHomebrew(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">err = c.depsUC.InstallGit()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">err = c.depsUC.CloneDotfiles()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">err = c.depsUC.InstallBrewBundle(initialSetupFlag)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

func (c *DofyControllerImpl) getMode() string <span class="cov0" title="0">{
        var mode string
        if len(os.Args) &gt; 1 </span><span class="cov0" title="0">{
                mode = strings.ToLower(os.Args[1])

                c.printoutUC.Println("The mode is set by command line arguments.")
        }</span> else<span class="cov0" title="0"> {
                c.printoutUC.Print("What mode do you use? [standard]: ")

                scanner := bufio.NewScanner(os.Stdin)
                if scanner.Scan() </span><span class="cov0" title="0">{
                        mode = strings.ToLower(strings.TrimSpace(scanner.Text()))
                        if mode == "" </span><span class="cov0" title="0">{
                                mode = "standard"
                        }</span>
                }
        }

        <span class="cov0" title="0">return mode</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package di

import (
        "github.com/google/wire"
        "github.com/shiron-dev/dotfiles/scripts/dofy/internal/adapter/controller"
        "github.com/shiron-dev/dotfiles/scripts/dofy/internal/infrastructure"
        "github.com/shiron-dev/dotfiles/scripts/dofy/internal/usecase"
        "io"
)

// Injectors from wire.go:

func InitializeControllerSet(stdout stdoutType, stderr stderrType) (*ControllersSet, error) <span class="cov0" title="0">{
        printOutInfrastructureImpl := providePrintOutInfrastructure(stdout, stderr)
        printOutUsecaseImpl := usecase.NewPrintOutUsecase(printOutInfrastructureImpl)
        configInfrastructureImpl := infrastructure.NewConfigInfrastructure()
        configUsecaseImpl := usecase.NewConfigUsecase(configInfrastructureImpl)
        depsInfrastructureImpl := infrastructure.NewDepsInfrastructure()
        brewInfrastructureImpl := infrastructure.NewBrewInfrastructure()
        fileInfrastructureImpl := infrastructure.NewFileInfrastructure()
        gitInfrastructureImpl := infrastructure.NewGitInfrastructure()
        brewUsecaseImpl := usecase.NewBrewUsecase(brewInfrastructureImpl, depsInfrastructureImpl, printOutUsecaseImpl, configUsecaseImpl)
        depsUsecaseImpl := usecase.NewDepsUsecase(depsInfrastructureImpl, brewInfrastructureImpl, fileInfrastructureImpl, gitInfrastructureImpl, printOutUsecaseImpl, brewUsecaseImpl)
        dofyControllerImpl := controller.NewDofyController(printOutUsecaseImpl, configUsecaseImpl, depsUsecaseImpl)
        controllersSet := &amp;ControllersSet{
                DofyController: dofyControllerImpl,
        }
        return controllersSet, nil
}</span>

func InitializeTestInfrastructureSet(stdout stdoutType, stderr stderrType) (*TestInfrastructureSet, error) <span class="cov8" title="1">{
        brewInfrastructureImpl := infrastructure.NewBrewInfrastructure()
        configInfrastructureImpl := infrastructure.NewConfigInfrastructure()
        depsInfrastructureImpl := infrastructure.NewDepsInfrastructure()
        fileInfrastructureImpl := infrastructure.NewFileInfrastructure()
        gitInfrastructureImpl := infrastructure.NewGitInfrastructure()
        printOutInfrastructureImpl := providePrintOutInfrastructure(stdout, stderr)
        testInfrastructureSet := &amp;TestInfrastructureSet{
                BrewInfrastructure:     brewInfrastructureImpl,
                ConfigInfrastructure:   configInfrastructureImpl,
                DepsInfrastructure:     depsInfrastructureImpl,
                FileInfrastructure:     fileInfrastructureImpl,
                GitInfrastructure:      gitInfrastructureImpl,
                PrintOutInfrastructure: printOutInfrastructureImpl,
        }
        return testInfrastructureSet, nil
}</span>

// wire.go:

type (
        stdoutType io.Writer
        stderrType io.Writer
)

func providePrintOutInfrastructure(stdout stdoutType, stderr stderrType) *infrastructure.PrintOutInfrastructureImpl <span class="cov8" title="1">{
        return infrastructure.NewPrintOutInfrastructure(stdout, stderr)
}</span>

// Adapter
var controllerSet = wire.NewSet(wire.Bind(new(controller.DofyController), new(*controller.DofyControllerImpl)), controller.NewDofyController)

// Infrastructure
var infrastructureSet = wire.NewSet(wire.Bind(new(infrastructure.PrintOutInfrastructure), new(*infrastructure.PrintOutInfrastructureImpl)), providePrintOutInfrastructure, wire.Bind(new(infrastructure.ConfigInfrastructure), new(*infrastructure.ConfigInfrastructureImpl)), infrastructure.NewConfigInfrastructure, wire.Bind(new(infrastructure.BrewInfrastructure), new(*infrastructure.BrewInfrastructureImpl)), infrastructure.NewBrewInfrastructure, wire.Bind(new(infrastructure.DepsInfrastructure), new(*infrastructure.DepsInfrastructureImpl)), infrastructure.NewDepsInfrastructure, wire.Bind(new(infrastructure.FileInfrastructure), new(*infrastructure.FileInfrastructureImpl)), infrastructure.NewFileInfrastructure, wire.Bind(new(infrastructure.GitInfrastructure), new(*infrastructure.GitInfrastructureImpl)), infrastructure.NewGitInfrastructure)

// Usecase
var usecaseSet = wire.NewSet(wire.Bind(new(usecase.PrintOutUsecase), new(*usecase.PrintOutUsecaseImpl)), usecase.NewPrintOutUsecase, wire.Bind(new(usecase.ConfigUsecase), new(*usecase.ConfigUsecaseImpl)), usecase.NewConfigUsecase, wire.Bind(new(usecase.BrewUsecase), new(*usecase.BrewUsecaseImpl)), usecase.NewBrewUsecase, wire.Bind(new(usecase.DepsUsecase), new(*usecase.DepsUsecaseImpl)), usecase.NewDepsUsecase)

type ControllersSet struct {
        DofyController controller.DofyController
}

type TestInfrastructureSet struct {
        BrewInfrastructure     infrastructure.BrewInfrastructure
        ConfigInfrastructure   infrastructure.ConfigInfrastructure
        DepsInfrastructure     infrastructure.DepsInfrastructure
        FileInfrastructure     infrastructure.FileInfrastructure
        GitInfrastructure      infrastructure.GitInfrastructure
        PrintOutInfrastructure infrastructure.PrintOutInfrastructure
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package domain

import "strings"

type BrewBundleType uint

const (
        BrewBundleTypeTap BrewBundleType = iota
        BrewBundleTypeFormula
        BrewBundleTypeCask
        BrewBundleTypeMas
)

type BrewBundle struct {
        Name       string
        Others     []string
        BundleType BrewBundleType
        Categories []string
}

func BrewBundleTypeFromString(str string) BrewBundleType <span class="cov8" title="1">{
        switch str </span>{
        case "tap":<span class="cov8" title="1">
                return BrewBundleTypeTap</span>
        case "brew":<span class="cov8" title="1">
                return BrewBundleTypeFormula</span>
        case "cask":<span class="cov0" title="0">
                return BrewBundleTypeCask</span>
        case "mas":<span class="cov8" title="1">
                return BrewBundleTypeMas</span>
        default:<span class="cov0" title="0">
                return BrewBundleTypeFormula</span>
        }
}

func (b BrewBundle) String() string <span class="cov8" title="1">{
        var str string

        switch b.BundleType </span>{
        case BrewBundleTypeTap:<span class="cov8" title="1">
                str = "tap"</span>
        case BrewBundleTypeFormula:<span class="cov8" title="1">
                str = "brew"</span>
        case BrewBundleTypeCask:<span class="cov0" title="0">
                str = "cask"</span>
        case BrewBundleTypeMas:<span class="cov8" title="1">
                str = "mas"</span>
        }

        <span class="cov8" title="1">str += " \"" + b.Name + "\""
        if len(b.Others) &gt; 0 </span><span class="cov8" title="1">{
                str += ", " + strings.Join(b.Others, ", ")
        }</span>

        <span class="cov8" title="1">return str</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package domain

import (
        "regexp"
        "strings"

        "github.com/fatih/color"
)

type MdPrinterType struct {
        Name    string
        Reg     *regexp.Regexp
        Col     *color.Color
        Printer func(string) string
}

//nolint:funlen
func GetMdPrinter() []MdPrinterType <span class="cov0" title="0">{
        return []MdPrinterType{
                {
                        "h1",
                        regexp.MustCompile(`(?m)^# (.+)`),
                        color.New(color.FgCyan),
                        nil,
                },
                {
                        "h2",
                        regexp.MustCompile(`(?m)^## (.*)`),
                        color.New(color.FgCyan),
                        nil,
                },
                {
                        "h3",
                        regexp.MustCompile(`(?m)^### (.*)`),
                        color.New(color.FgCyan),
                        nil,
                },
                {
                        "h4",
                        regexp.MustCompile(`(?m)^#### (.*)`),
                        color.New(color.FgCyan),
                        nil,
                },
                {
                        "h5",
                        regexp.MustCompile(`(?m)^##### (.*)`),
                        color.New(color.FgCyan),
                        nil,
                },
                {
                        "h6",
                        regexp.MustCompile(`(?m)^###### (.*)`),
                        color.New(color.FgCyan),
                        nil,
                },
                {
                        "bold",
                        regexp.MustCompile(`\*\*(.*)\*\*`),
                        color.New(color.Bold),
                        nil,
                },
                {
                        "italic",
                        regexp.MustCompile(`\*(.*)\*`),
                        color.New(color.Italic),
                        nil,
                },
                {
                        "code",
                        regexp.MustCompile("`(.*)`"),
                        color.New(color.FgHiWhite),
                        nil,
                },
                {
                        "underline",
                        nil,
                        nil,
                        func(str string) string </span><span class="cov0" title="0">{
                                re := regexp.MustCompile(`__(.*)__`)

                                return re.ReplaceAllStringFunc(str, func(s string) string </span><span class="cov0" title="0">{
                                        return re.ReplaceAllString(s, color.New(color.Underline).Sprint("$1"))
                                }</span>)
                        },
                },
                {
                        "alert",
                        nil,
                        nil,
                        func(str string) string <span class="cov0" title="0">{
                                ret := ""

                                reg := regexp.MustCompile(`^&gt; \[!(.+?)\]$`)

                                var fgColor *color.Color
                                for _, line := range strings.Split(str, "\n") </span><span class="cov0" title="0">{
                                        if reg.MatchString(line) </span><span class="cov0" title="0">{
                                                emoji := ""
                                                switch reg.FindStringSubmatch(line)[1] </span>{
                                                case "NOTE":<span class="cov0" title="0">
                                                        fgColor = color.New(color.FgBlue)
                                                        emoji = "üìù"</span>
                                                case "TIP":<span class="cov0" title="0">
                                                        fgColor = color.New(color.FgGreen)
                                                        emoji = "üí°"</span>
                                                case "IMPORTANT":<span class="cov0" title="0">
                                                        fgColor = color.New(color.FgMagenta)
                                                        emoji = "‚ùó"</span>
                                                case "WARNING":<span class="cov0" title="0">
                                                        //nolint:mnd
                                                        fgColor = color.RGB(255, 128, 0)
                                                        emoji = "‚ö†Ô∏è"</span>
                                                case "CAUTION":<span class="cov0" title="0">
                                                        fgColor = color.New(color.FgRed)
                                                        emoji = "üö®"</span>
                                                }
                                                <span class="cov0" title="0">ret += fgColor.SprintFunc()("|"+strings.ReplaceAll(line[1:], "!", emoji)) + "\n"

                                                continue</span>
                                        }

                                        <span class="cov0" title="0">if !strings.HasPrefix(line, "&gt;") </span><span class="cov0" title="0">{
                                                fgColor = nil
                                        }</span>

                                        <span class="cov0" title="0">if fgColor != nil </span><span class="cov0" title="0">{
                                                ret += fgColor.SprintFunc()("|") + line[1:] + "\n"
                                        }</span> else<span class="cov0" title="0"> {
                                                ret += line + "\n"
                                        }</span>
                                }

                                <span class="cov0" title="0">return ret</span>
                        },
                },
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package infrastructure

import (
        "bufio"
        "context"
        "io"
        "net/http"
        "os"
        "os/exec"
        "sort"
        "strings"

        "github.com/pkg/errors"
        "github.com/shiron-dev/dotfiles/scripts/dofy/internal/domain"
)

type BrewInfrastructure interface {
        InstallHomebrew(ctx context.Context, sout io.Writer, serror io.Writer) error
        SetHomebrewEnv(goos string) error
        InstallFormula(pkg string, sout io.Writer, serror io.Writer) error
        InstallTap(pkg string, sout io.Writer, serror io.Writer) error
        InstallByMas(pkg string, sout io.Writer, serror io.Writer) error
        DumpTmpBrewBundle(path string, isMac bool, sout io.Writer, serror io.Writer) error
        InstallBrewBundle(path string, sout io.Writer, serror io.Writer) error
        CleanupBrewBundle(path string, isForce bool, sout io.Writer, serror io.Writer) error
        ReadBrewBundle(path string) ([]domain.BrewBundle, error)
        WriteBrewBundle(path string, bundles []domain.BrewBundle) error
}

type BrewInfrastructureImpl struct{}

func NewBrewInfrastructure() *BrewInfrastructureImpl <span class="cov8" title="1">{
        return &amp;BrewInfrastructureImpl{}
}</span>

func (b *BrewInfrastructureImpl) InstallHomebrew(ctx context.Context, sout io.Writer, serror io.Writer) error <span class="cov8" title="1">{
        url := "https://raw.githubusercontent.com/Homebrew/install/master/install.sh"

        req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "brew infrastructure: failed to create request")
        }</span>

        <span class="cov8" title="1">resp, err := http.DefaultClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "brew infrastructure: failed to send request")
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        bytes, _ := io.ReadAll(resp.Body)

        //nolint:gosec
        cmd := exec.Command("/bin/bash", "-c", string(bytes))
        cmd.Stdout = sout
        cmd.Stderr = serror

        if err = cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "brew infrastructure: failed to run command")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (b *BrewInfrastructureImpl) SetHomebrewEnv(goos string) error <span class="cov8" title="1">{
        var brewPath string

        switch goos </span>{
        case "darwin":<span class="cov0" title="0">
                brewPath = "/opt/homebrew/bin/brew"</span>
        case "linux":<span class="cov8" title="1">
                brewPath = "/home/linuxbrew/.linuxbrew/bin/brew"</span>
        }

        <span class="cov8" title="1">cmd := exec.Command(brewPath, "shellenv")

        shellenv, err := cmd.Output()
        if err != nil </span><span class="cov8" title="1">{
                return errors.Wrap(err, "brew infrastructure: failed to get shellenv")
        }</span>

        <span class="cov8" title="1">for _, line := range strings.Split(string(shellenv), "\n") </span><span class="cov8" title="1">{
                if strings.HasPrefix(line, "export PATH=") </span><span class="cov8" title="1">{
                        //nolint:gosec
                        cmd = exec.Command("sh", "-c", "echo "+strings.Replace(line, "export PATH=", "", 1))
                        out, _ := cmd.Output()
                        os.Setenv("PATH", strings.Trim(string(out), "\""))
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (b *BrewInfrastructureImpl) InstallFormula(formula string, sout io.Writer, serror io.Writer) error <span class="cov8" title="1">{
        cmd := exec.Command("brew", "install", formula)
        cmd.Stdout = sout
        cmd.Stderr = serror

        if err := cmd.Run(); err != nil </span><span class="cov8" title="1">{
                return errors.Wrap(err, "brew infrastructure: failed to run brew install command")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (b *BrewInfrastructureImpl) InstallTap(formula string, sout io.Writer, serror io.Writer) error <span class="cov8" title="1">{
        cmd := exec.Command("brew", "tap", formula)
        cmd.Stdout = sout
        cmd.Stderr = serror

        if err := cmd.Run(); err != nil </span><span class="cov8" title="1">{
                return errors.Wrap(err, "brew infrastructure: failed to run brew tap command")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (b *BrewInfrastructureImpl) InstallByMas(pkg string, sout io.Writer, serror io.Writer) error <span class="cov0" title="0">{
        cmd := exec.Command("mas", "install", pkg)
        cmd.Stdout = sout
        cmd.Stderr = serror

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "brew infrastructure: failed to run mas install command")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (b *BrewInfrastructureImpl) DumpTmpBrewBundle(path string, isMac bool, sout io.Writer, serror io.Writer) error <span class="cov8" title="1">{
        if _, err := os.Stat(path); err == nil </span><span class="cov8" title="1">{
                os.Remove(path)
        }</span>

        <span class="cov8" title="1">args := []string{"bundle", "dump", "--tap", "--formula"}

        if isMac </span><span class="cov8" title="1">{
                args = append(args, "--cask", "--mas")
        }</span>

        <span class="cov8" title="1">args = append(args, "--file", path)

        cmd := exec.Command("brew", args...)
        cmd.Stdout = sout
        cmd.Stderr = serror

        if err := cmd.Run(); err != nil </span><span class="cov8" title="1">{
                return errors.Wrap(err, "brew infrastructure: failed to run brew bundle dump command")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (b *BrewInfrastructureImpl) InstallBrewBundle(path string, sout io.Writer, serror io.Writer) error <span class="cov8" title="1">{
        cmd := exec.Command("brew", "bundle", "--no-lock", "--file", path)
        cmd.Stdout = sout
        cmd.Stderr = serror

        if err := cmd.Run(); err != nil </span><span class="cov8" title="1">{
                return errors.Wrap(err, "brew infrastructure: failed to run brew bundle command")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (b *BrewInfrastructureImpl) CleanupBrewBundle(path string, isForce bool, sout io.Writer, serror io.Writer) error <span class="cov0" title="0">{
        forceFlag := ""

        if isForce </span><span class="cov0" title="0">{
                forceFlag = "--force"
        }</span>

        <span class="cov0" title="0">cmd := exec.Command("brew", "bundle", "cleanup", forceFlag, "--file", path)
        cmd.Stdout = sout
        cmd.Stderr = serror

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "brew infrastructure: failed to run brew bundle cleanup command")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (b *BrewInfrastructureImpl) ReadBrewBundle(path string) ([]domain.BrewBundle, error) <span class="cov8" title="1">{
        file, err := os.Open(path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, "deps infrastructure: failed to open file")
        }</span>
        <span class="cov8" title="1">defer file.Close()

        scanner := bufio.NewScanner(file)

        var bundles []domain.BrewBundle

        lastCategories := []string{}

        for scanner.Scan() </span><span class="cov8" title="1">{
                line := scanner.Text()

                if len(line) == 0 </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if line[0] == '#' </span><span class="cov8" title="1">{
                        lastCategories = getCategory(line, lastCategories)

                        continue</span>
                }

                <span class="cov8" title="1">spInd := strings.Index(line, " ")
                if spInd == -1 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">prefix := line[:spInd]
                formula := line[spInd+1:]
                cFormula := strings.Split(formula, ",")

                others := []string{}
                for _, c := range cFormula[1:] </span><span class="cov8" title="1">{
                        others = append(others, strings.TrimSpace(c))
                }</span>

                <span class="cov8" title="1">bundles = append(bundles, domain.BrewBundle{
                        Name:       strings.TrimSpace(strings.Trim(strings.ReplaceAll(cFormula[0], ",", ""), "\"")),
                        Others:     others,
                        BundleType: domain.BrewBundleTypeFromString(prefix),
                        Categories: append([]string{}, lastCategories...),
                })</span>
        }

        <span class="cov8" title="1">return bundles, nil</span>
}

func getCategory(line string, lastCategories []string) []string <span class="cov8" title="1">{
        count := 0

        for _, c := range line </span><span class="cov8" title="1">{
                if c == '#' </span><span class="cov8" title="1">{
                        count++
                }</span> else<span class="cov8" title="1"> {
                        break</span>
                }
        }

        <span class="cov8" title="1">size := len(lastCategories)
        for i := count - 1; i &lt; size; i++ </span><span class="cov8" title="1">{
                lastCategories = lastCategories[:len(lastCategories)-1]
        }</span>

        <span class="cov8" title="1">lastCategories = append(lastCategories, strings.TrimSpace(line[count:]))

        return lastCategories</span>
}

func (b *BrewInfrastructureImpl) WriteBrewBundle(path string, bundles []domain.BrewBundle) error <span class="cov8" title="1">{
        file, err := os.Create(path)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "deps infrastructure: failed to create file")
        }</span>
        <span class="cov8" title="1">defer file.Close()

        if _, err := file.WriteString("# Brewfile made by dofy\n"); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "deps infrastructure: failed to write file")
        }</span>

        <span class="cov8" title="1">bundleMap := sortByCategories(bundles)

        lastCategories := []string{}

        writeString := ""

        for _, bundle := range bundleMap </span><span class="cov8" title="1">{
                for i, cate := range bundle.Categories </span><span class="cov8" title="1">{
                        if len(lastCategories) &gt; i &amp;&amp; lastCategories[i] == cate </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">for j := 0; j &lt;= i; j++ </span><span class="cov8" title="1">{
                                if j == 0 </span><span class="cov8" title="1">{
                                        writeString += "\n"
                                }</span>

                                <span class="cov8" title="1">writeString += "#"</span>
                        }

                        <span class="cov8" title="1">writeString += " " + cate + "\n"</span>
                }

                <span class="cov8" title="1">lastCategories = bundle.Categories

                writeString += bundle.String() + "\n"</span>
        }

        <span class="cov8" title="1">if _, err := file.WriteString(writeString); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "deps infrastructure: failed to write file")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

type cateKey string

func toCateKey(cate []string) cateKey <span class="cov8" title="1">{
        return cateKey(strings.Join(cate, ","))
}</span>

func sortByCategories(bundles []domain.BrewBundle) []domain.BrewBundle <span class="cov8" title="1">{
        categoriesOrder := [][]string{}

        bundleMap := make(map[cateKey][]domain.BrewBundle)

        for _, bundle := range bundles </span><span class="cov8" title="1">{
                if _, ok := bundleMap[toCateKey(bundle.Categories)]; !ok </span><span class="cov8" title="1">{
                        categoriesOrder = append(categoriesOrder, bundle.Categories)
                }</span>

                <span class="cov8" title="1">bundleMap[toCateKey(bundle.Categories)] = append(bundleMap[toCateKey(bundle.Categories)], bundle)</span>
        }

        <span class="cov8" title="1">for _, bundles := range bundleMap </span><span class="cov8" title="1">{
                sort.Slice(bundles, func(i, j int) bool </span><span class="cov8" title="1">{
                        if bundles[i].BundleType != bundles[j].BundleType </span><span class="cov8" title="1">{
                                return bundles[i].BundleType &lt; bundles[j].BundleType
                        }</span>

                        <span class="cov8" title="1">return bundles[i].Name &lt; bundles[j].Name</span>
                })
        }

        <span class="cov8" title="1">var sortedBundles []domain.BrewBundle

        for _, categories := range categoriesOrder </span><span class="cov8" title="1">{
                sortedBundles = append(sortedBundles, bundleMap[toCateKey(categories)]...)
        }</span>

        <span class="cov8" title="1">return sortedBundles</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package infrastructure

import (
        "os/exec"
        "runtime"
        "strings"

        "github.com/pkg/errors"
)

type ConfigInfrastructure interface {
        GetOS() (string, error)
        GetOSVersion() (string, error)
        GetArch() (string, error)
}

type ConfigInfrastructureImpl struct{}

func NewConfigInfrastructure() *ConfigInfrastructureImpl <span class="cov8" title="1">{
        return &amp;ConfigInfrastructureImpl{}
}</span>

func (c *ConfigInfrastructureImpl) GetOS() (string, error) <span class="cov8" title="1">{
        return runtime.GOOS, nil
}</span>

func (c *ConfigInfrastructureImpl) GetOSVersion() (string, error) <span class="cov8" title="1">{
        osVersion, err := exec.Command("uname", "-r").Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.Wrap(err, "config infrastructure: failed to get os version")
        }</span>

        <span class="cov8" title="1">return strings.TrimSpace(string(osVersion)), nil</span>
}

func (c *ConfigInfrastructureImpl) GetArch() (string, error) <span class="cov8" title="1">{
        arch, err := exec.Command("uname", "-p").Output()
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.Wrap(err, "config infrastructure: failed to get arch")
        }</span>

        <span class="cov8" title="1">return strings.TrimSpace(string(arch)), nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package infrastructure

import (
        "os/exec"

        "github.com/pkg/errors"
)

type DepsInfrastructure interface {
        CheckInstalled(name string) bool
        OpenWithCode(path ...string) error
}

type DepsInfrastructureImpl struct{}

func NewDepsInfrastructure() *DepsInfrastructureImpl <span class="cov8" title="1">{
        return &amp;DepsInfrastructureImpl{}
}</span>

func (d *DepsInfrastructureImpl) CheckInstalled(name string) bool <span class="cov8" title="1">{
        _, err := exec.LookPath(name)

        return err == nil
}</span>

func (d *DepsInfrastructureImpl) OpenWithCode(path ...string) error <span class="cov0" title="0">{
        args := []string{"-n", "-w"}
        args = append(args, path...)

        if err := exec.Command("code", args...).Run(); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "deps infrastructure: failed to open with code")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package infrastructure

import (
        "os"

        "github.com/pkg/errors"
)

type FileInfrastructure interface {
        ReadFile(path string) ([]byte, error)
        WriteFile(path string, data []byte) error
}

type FileInfrastructureImpl struct{}

func NewFileInfrastructure() *FileInfrastructureImpl <span class="cov8" title="1">{
        return &amp;FileInfrastructureImpl{}
}</span>

const filePermission = 0o666

func (f *FileInfrastructureImpl) ReadFile(path string) ([]byte, error) <span class="cov8" title="1">{
        if _, err := os.Stat(path); err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, "file infrastructure: failed to open file")
        }</span>

        <span class="cov8" title="1">data, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Wrap(err, "file infrastructure: failed to read file")
        }</span>

        <span class="cov8" title="1">return data, nil</span>
}

func (f *FileInfrastructureImpl) WriteFile(path string, data []byte) error <span class="cov8" title="1">{
        if err := os.WriteFile(path, data, filePermission); err != nil </span><span class="cov8" title="1">{
                return errors.Wrap(err, "file infrastructure: failed to write file")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package infrastructure

import (
        "context"
        "io"
        "os/exec"

        "github.com/pkg/errors"
)

type GitInfrastructure interface {
        SetGitDir(path string)
        GitDifftool(ctx context.Context, sout io.Writer, serror io.Writer, path ...string) error
        CheckoutFile(path string) error
}

type GitInfrastructureImpl struct {
        gitDir string
}

func NewGitInfrastructure() *GitInfrastructureImpl <span class="cov8" title="1">{
        return &amp;GitInfrastructureImpl{
                gitDir: "",
        }
}</span>

var ErrGitDirNotSet = errors.New("git infrastructure: git directory is not set")

func (g *GitInfrastructureImpl) SetGitDir(path string) <span class="cov8" title="1">{
        g.gitDir = path
}</span>

func (g *GitInfrastructureImpl) GitDifftool(
        ctx context.Context,
        sout io.Writer,
        serror io.Writer,
        path ...string,
) error <span class="cov8" title="1">{
        if g.gitDir == "" </span><span class="cov8" title="1">{
                return ErrGitDirNotSet
        }</span>

        <span class="cov8" title="1">args := []string{"difftool", "-y"}
        args = append(args, path...)

        cmd := exec.CommandContext(ctx, "git", args...)
        cmd.Dir = g.gitDir
        cmd.Stdout = sout
        cmd.Stderr = serror

        if err := cmd.Run(); err != nil </span><span class="cov8" title="1">{
                return errors.Wrap(err, "git infrastructure: failed to run git difftool")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (g *GitInfrastructureImpl) CheckoutFile(path string) error <span class="cov8" title="1">{
        if g.gitDir == "" </span><span class="cov8" title="1">{
                return ErrGitDirNotSet
        }</span>

        <span class="cov8" title="1">cmd := exec.Command("git", "checkout", "--", path)
        cmd.Dir = g.gitDir

        if err := cmd.Run(); err != nil </span><span class="cov8" title="1">{
                return errors.Wrap(err, "git infrastructure: failed to run git checkout")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package infrastructure

import (
        "fmt"
        "io"
        "log"
        "os"
)

type PrintOutInfrastructure interface {
        Print(str string)
        SetLogOutput(logFile *os.File)

        GetOut() *io.Writer
        GetError() *io.Writer
}

type PrintOutInfrastructureImpl struct {
        out    io.Writer
        err    io.Writer
        stdout io.Writer
        stderr io.Writer
}

func NewPrintOutInfrastructure(stdout io.Writer, stderr io.Writer) *PrintOutInfrastructureImpl <span class="cov8" title="1">{
        return &amp;PrintOutInfrastructureImpl{
                out:    stdout,
                err:    stderr,
                stdout: stdout,
                stderr: stderr,
        }
}</span>

func (p *PrintOutInfrastructureImpl) Print(str string) <span class="cov8" title="1">{
        log.Print(str)
        fmt.Fprint(p.stdout, str)
}</span>

func (p *PrintOutInfrastructureImpl) SetLogOutput(logFile *os.File) <span class="cov8" title="1">{
        log.SetOutput(logFile)

        log.SetFlags(log.Ldate | log.Ltime)

        p.out = io.MultiWriter(p.stdout, logFile)
        p.err = io.MultiWriter(p.stderr, logFile)
}</span>

func (p *PrintOutInfrastructureImpl) GetOut() *io.Writer <span class="cov8" title="1">{
        return &amp;p.out
}</span>

func (p *PrintOutInfrastructureImpl) GetError() *io.Writer <span class="cov8" title="1">{
        return &amp;p.err
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package util

import (
        "os"
        "os/exec"
        "testing"
)

const gitRepoPermission = 0o755

func MakeGitRepo(t *testing.T) string <span class="cov8" title="1">{
        t.Helper()

        workingDir := t.TempDir()
        path := workingDir + "/git_temp"

        err := os.MkdirAll(path, gitRepoPermission)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatal(err)
        }</span>

        <span class="cov8" title="1">cmd := exec.Command("git", "init")
        cmd.Dir = path

        if err = cmd.Run(); err != nil </span><span class="cov0" title="0">{
                t.Fatal(err)
        }</span>

        <span class="cov8" title="1">cmd = exec.Command("git", "config", "user.email", "test@example.com")
        cmd.Dir = path

        if err = cmd.Run(); err != nil </span><span class="cov0" title="0">{
                t.Fatal(err)
        }</span>

        <span class="cov8" title="1">cmd = exec.Command("git", "config", "user.name", "test")
        cmd.Dir = path

        if err = cmd.Run(); err != nil </span><span class="cov0" title="0">{
                t.Fatal(err)
        }</span>

        <span class="cov8" title="1">cmd = exec.Command("git", "config", "commit.gpgSign", "false")
        cmd.Dir = path

        if err = cmd.Run(); err != nil </span><span class="cov0" title="0">{
                t.Fatal(err)
        }</span>

        <span class="cov8" title="1">return path</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package util

import (
        "os"
        "testing"

        "github.com/pkg/errors"
)

func IsCI() bool <span class="cov8" title="1">{
        return os.Getenv("GITHUB_ACIONS") == "true"
}</span>

func MakeUnOpenableFile(t *testing.T) (string, error) <span class="cov8" title="1">{
        t.Helper()

        path := t.TempDir() + "/unopenable"

        file, err := os.Create(path)
        if err != nil </span><span class="cov0" title="0">{
                return path, errors.Wrap(err, "failed to create file")
        }</span>
        <span class="cov8" title="1">defer file.Close()

        err = os.Chmod(path, 0)

        return path, errors.Wrap(err, "failed to chmod")</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package usecase

import (
        "context"

        "github.com/pkg/errors"
        "github.com/shiron-dev/dotfiles/scripts/dofy/internal/domain"
        "github.com/shiron-dev/dotfiles/scripts/dofy/internal/infrastructure"
)

type BrewUsecase interface {
        InstallHomebrew(ctx context.Context) error
        InstallFormula(formula string, bType domain.BrewBundleType) error
        InstallBrewBundle(path string) error
        DumpTmpBrewBundle(path string) error
        CheckDiffBrewBundle(bundlePath string, tmpPath string) ([]domain.BrewBundle, []domain.BrewBundle, error)
        CleanupBrewBundle(path string, isForce bool) error
}

type BrewUsecaseImpl struct {
        brewInfrastructure infrastructure.BrewInfrastructure
        depsInfrastructure infrastructure.DepsInfrastructure
        printOutUC         PrintOutUsecase
        configUC           ConfigUsecase
}

func NewBrewUsecase(
        brewInfrastructure infrastructure.BrewInfrastructure,
        depsInfrastructure infrastructure.DepsInfrastructure,
        printOutUC PrintOutUsecase,
        configUC ConfigUsecase,
) *BrewUsecaseImpl <span class="cov0" title="0">{
        return &amp;BrewUsecaseImpl{
                brewInfrastructure: brewInfrastructure,
                depsInfrastructure: depsInfrastructure,
                printOutUC:         printOutUC,
                configUC:           configUC,
        }
}</span>

func (b *BrewUsecaseImpl) InstallHomebrew(ctx context.Context) error <span class="cov0" title="0">{
        b.printOutUC.PrintMdf(`
### Installing Homebrew
`)

        err := b.brewInfrastructure.InstallHomebrew(ctx, *b.printOutUC.GetOut(), *b.printOutUC.GetError())
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "brew usecase: failed to install Homebrew")
        }</span>

        <span class="cov0" title="0">b.printOutUC.PrintMdf(`
### Set Homebrew environment
`)

        cfg, err := b.configUC.ScanEnvInfo()
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "brew usecase: failed to get environment info")
        }</span>

        <span class="cov0" title="0">err = b.brewInfrastructure.SetHomebrewEnv(cfg.os)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "brew usecase: failed to set Homebrew environment")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (b *BrewUsecaseImpl) InstallFormula(formula string, bType domain.BrewBundleType) error <span class="cov0" title="0">{
        b.printOutUC.PrintMdf(`
### Installing %s (with Homebrew)
`, formula)

        var err error

        switch bType </span>{
        case domain.BrewBundleTypeTap:<span class="cov0" title="0">
                err = b.brewInfrastructure.InstallTap(formula, *b.printOutUC.GetOut(), *b.printOutUC.GetError())</span>
        case domain.BrewBundleTypeFormula:<span class="cov0" title="0"></span>
        case domain.BrewBundleTypeCask:<span class="cov0" title="0">
                err = b.brewInfrastructure.InstallFormula(formula, *b.printOutUC.GetOut(), *b.printOutUC.GetError())</span>
        case domain.BrewBundleTypeMas:<span class="cov0" title="0">
                err = b.brewInfrastructure.InstallByMas(formula, *b.printOutUC.GetOut(), *b.printOutUC.GetError())</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "brew usecase: failed to install formula")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (b *BrewUsecaseImpl) InstallBrewBundle(path string) error <span class="cov0" title="0">{
        err := b.brewInfrastructure.InstallBrewBundle(path, *b.printOutUC.GetOut(), *b.printOutUC.GetError())
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "brew usecase: failed to install Brewfile")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (b *BrewUsecaseImpl) DumpTmpBrewBundle(path string) error <span class="cov0" title="0">{
        cfg, err := b.configUC.ScanEnvInfo()
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "brew usecase: failed to get environment info")
        }</span>

        <span class="cov0" title="0">err = b.brewInfrastructure.DumpTmpBrewBundle(path, cfg.isMac, *b.printOutUC.GetOut(), *b.printOutUC.GetError())
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "brew usecase: failed to dump Brewfile.tmp")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (b *BrewUsecaseImpl) CheckDiffBrewBundle(
        bundlePath string,
        tmpPath string,
) ([]domain.BrewBundle, []domain.BrewBundle, error) <span class="cov0" title="0">{
        bundles, err := b.brewInfrastructure.ReadBrewBundle(bundlePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errors.Wrap(err, "brew usecase: failed to read Brewfile")
        }</span>

        <span class="cov0" title="0">tmpBundles, err := b.brewInfrastructure.ReadBrewBundle(tmpPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, errors.Wrap(err, "brew usecase: failed to read Brewfile.tmp")
        }</span>

        <span class="cov0" title="0">tmpBundlesMap := make(map[string]bool)

        var diffBundles []domain.BrewBundle

        for _, bundle := range bundles </span><span class="cov0" title="0">{
                isFound := false

                for _, tmpBundle := range tmpBundles </span><span class="cov0" title="0">{
                        if bundle.Name == tmpBundle.Name &amp;&amp; bundle.BundleType == tmpBundle.BundleType </span><span class="cov0" title="0">{
                                isFound = true
                                tmpBundlesMap[bundle.Name] = true
                        }</span>
                }

                <span class="cov0" title="0">if !isFound </span><span class="cov0" title="0">{
                        diffBundles = append(diffBundles, bundle)
                }</span>
        }

        <span class="cov0" title="0">var diffTmpBundles []domain.BrewBundle

        for _, tmpBundle := range tmpBundles </span><span class="cov0" title="0">{
                if _, ok := tmpBundlesMap[tmpBundle.Name]; !ok </span><span class="cov0" title="0">{
                        diffTmpBundles = append(diffTmpBundles, tmpBundle)
                }</span>
        }

        <span class="cov0" title="0">return diffBundles, diffTmpBundles, nil</span>
}

func (b *BrewUsecaseImpl) CleanupBrewBundle(path string, isForce bool) error <span class="cov0" title="0">{
        err := b.brewInfrastructure.CleanupBrewBundle(path, isForce, *b.printOutUC.GetOut(), *b.printOutUC.GetError())
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "brew usecase: failed to cleanup Brewfile")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package usecase

import (
        "github.com/pkg/errors"
        "github.com/shiron-dev/dotfiles/scripts/dofy/internal/infrastructure"
)

type ConfigUsecase interface {
        ScanEnvInfo() (*EnvInfo, error)
}

type ConfigUsecaseImpl struct {
        configInfrastructure infrastructure.ConfigInfrastructure
}

func NewConfigUsecase(configInfrastructure infrastructure.ConfigInfrastructure) *ConfigUsecaseImpl <span class="cov0" title="0">{
        return &amp;ConfigUsecaseImpl{
                configInfrastructure: configInfrastructure,
        }
}</span>

type EnvInfo struct {
        os        string
        osVersion string
        arch      string
        isMac     bool
}

func (c *ConfigUsecaseImpl) ScanEnvInfo() (*EnvInfo, error) <span class="cov0" title="0">{
        gos, err := c.configInfrastructure.GetOS()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "config usecase: failed to get os")
        }</span>

        <span class="cov0" title="0">osVersion, err := c.configInfrastructure.GetOSVersion()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "config usecase: failed to get os version")
        }</span>

        <span class="cov0" title="0">arch, err := c.configInfrastructure.GetArch()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "config usecase: failed to get arch")
        }</span>

        <span class="cov0" title="0">return &amp;EnvInfo{
                os:        gos,
                osVersion: osVersion,
                arch:      arch,
                isMac:     gos == "darwin",
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package usecase

import (
        "bufio"
        "context"
        "os"
        "os/exec"
        "os/signal"
        "os/user"
        "path/filepath"
        "strings"
        "syscall"

        "github.com/fatih/color"
        "github.com/pkg/errors"
        "github.com/shiron-dev/dotfiles/scripts/dofy/internal/domain"
        "github.com/shiron-dev/dotfiles/scripts/dofy/internal/infrastructure"
)

const dofyBrewCategory = "Add by dofy"

const resolveBrewDiffWithEditorMaxCount = 3

var errResolveBrewDiffWithEditorMaxCount = errors.New("resolve brew diff with editor max count error")

type DepsUsecase interface {
        CheckInstalled(name string) bool
        InstallHomebrew(ctx context.Context) error
        InstallGit() error
        CloneDotfiles() error
        InstallBrewBundle(forceInstall bool) error
        Finish() error

        showBrewDiff(
                diffBundles []domain.BrewBundle,
                diffTmpBundles []domain.BrewBundle,
                brewPath string, brewTmpPath string,
        ) error
        updateBrewfile(brewPath string, brewTmpPath string) error
        resolveBrewDiff(brewPath string, brewTmpPath string) error
        resolveBrewDiffWithEditor(ctx context.Context, brewPath string) error
}

type DepsUsecaseImpl struct {
        depsInfrastructure infrastructure.DepsInfrastructure
        brewInfrastructure infrastructure.BrewInfrastructure
        fileInfrastructure infrastructure.FileInfrastructure
        gitInfrastructure  infrastructure.GitInfrastructure
        printOutUC         PrintOutUsecase
        brewUC             BrewUsecase

        resolveBrewDiffWithEditorCount int
}

func NewDepsUsecase(
        depsInfrastructure infrastructure.DepsInfrastructure,
        brewInfrastructure infrastructure.BrewInfrastructure,
        fileInfrastructure infrastructure.FileInfrastructure,
        gitInfrastructure infrastructure.GitInfrastructure,
        printOutUC PrintOutUsecase,
        brewUC BrewUsecase,
) *DepsUsecaseImpl <span class="cov0" title="0">{
        return &amp;DepsUsecaseImpl{
                depsInfrastructure:             depsInfrastructure,
                brewInfrastructure:             brewInfrastructure,
                fileInfrastructure:             fileInfrastructure,
                gitInfrastructure:              gitInfrastructure,
                printOutUC:                     printOutUC,
                brewUC:                         brewUC,
                resolveBrewDiffWithEditorCount: 0,
        }
}</span>

func (d *DepsUsecaseImpl) CheckInstalled(name string) bool <span class="cov0" title="0">{
        return d.depsInfrastructure.CheckInstalled(name)
}</span>

func (d *DepsUsecaseImpl) InstallHomebrew(ctx context.Context) error <span class="cov0" title="0">{
        d.printOutUC.PrintMdf(`
## Installing Homebrew
`)

        if d.depsInfrastructure.CheckInstalled("brew") </span><span class="cov0" title="0">{
                d.printOutUC.Println("Homebrew is already installed")
        }</span> else<span class="cov0" title="0"> {
                err := d.brewUC.InstallHomebrew(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "deps usecase: failed to install Homebrew")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (d *DepsUsecaseImpl) InstallGit() error <span class="cov0" title="0">{
        d.printOutUC.PrintMdf(`
## Installing required packages with Homebrew

- git
`)

        if d.depsInfrastructure.CheckInstalled("git") </span><span class="cov0" title="0">{
                d.printOutUC.Println("git is already installed")
        }</span> else<span class="cov0" title="0"> {
                err := d.brewUC.InstallFormula("git", domain.BrewBundleTypeFormula)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "deps usecase: failed to install git")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (d *DepsUsecaseImpl) CloneDotfiles() error <span class="cov0" title="0">{
        d.printOutUC.PrintMdf(`
## Git clone dotfiles repository

https://github.com/shiron-dev/dotfiles.git
`)

        usr, err := user.Current()
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "deps usecase: failed to get current user")
        }</span>

        <span class="cov0" title="0">if _, err := os.Stat(usr.HomeDir + "/projects/dotfiles"); err == nil </span><span class="cov0" title="0">{
                d.printOutUC.Println("dotfiles directory already exists")
        }</span> else<span class="cov0" title="0"> {
                d.printOutUC.Println("Cloning dotfiles repository")

                //nolint:gosec
                cmd := exec.Command(
                        "git",
                        "clone",
                        "https://github.com/shiron-dev/dotfiles.git",
                        filepath.Join(usr.HomeDir, "/projects/dotfiles"),
                )
                if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "deps usecase: failed to clone dotfiles repository")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (d *DepsUsecaseImpl) InstallBrewBundle(forceInstall bool) error <span class="cov0" title="0">{
        usr, err := user.Current()
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "deps usecase: failed to get current user")
        }</span>

        <span class="cov0" title="0">brewPath := usr.HomeDir + "/projects/dotfiles/data/Brewfile"
        brewTmpPath := usr.HomeDir + "/projects/dotfiles/data/Brewfile.tmp"

        d.printOutUC.PrintMdf(`
## Installing brew packages

Install the packages using Homebrew Bundle.
`)

        d.printOutUC.PrintMdf(`
### Install brew bundle

` + "`brew tap Homebrew/bundle`\n")

        if err := d.brewUC.InstallFormula("Homebrew/bundle", domain.BrewBundleTypeTap); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "deps usecase: failed to install Homebrew/bundle")
        }</span>

        <span class="cov0" title="0">err = d.brewUC.DumpTmpBrewBundle(brewTmpPath)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "deps usecase: failed to dump tmp Brewfile")
        }</span>

        <span class="cov0" title="0">diffBundles, diffTmpBundles, err := d.brewUC.CheckDiffBrewBundle(brewPath, brewTmpPath)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "deps usecase: failed to check diff Brewfile")
        }</span>

        <span class="cov0" title="0">if !forceInstall &amp;&amp; len(diffTmpBundles)+len(diffTmpBundles) &gt; 0 </span><span class="cov0" title="0">{
                err := d.showBrewDiff(diffBundles, diffTmpBundles, brewPath, brewTmpPath)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "deps usecase: failed to update Brewfile")
                }</span>
        }

        <span class="cov0" title="0">d.printOutUC.PrintMdf(`
### Install brew packages with Brewfile
`)

        if err := d.brewUC.InstallBrewBundle(brewPath); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "deps usecase: failed to install brew packages")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (d *DepsUsecaseImpl) Finish() error <span class="cov0" title="0">{
        d.printOutUC.PrintMdf(`
## Finish
`)

        os.Exit(0)

        return nil
}</span>

func (d *DepsUsecaseImpl) showBrewDiff(
        diffBundles []domain.BrewBundle,
        diffTmpBundles []domain.BrewBundle,
        brewPath string, brewTmpPath string,
) error <span class="cov0" title="0">{
        var diffNames string
        for _, diff := range diffTmpBundles </span><span class="cov0" title="0">{
                diffNames += color.GreenString("+ " + diff.Name + "\n")
        }</span>

        <span class="cov0" title="0">for _, diff := range diffBundles </span><span class="cov0" title="0">{
                diffNames += color.RedString("- " + diff.Name + "\n")
        }</span>

        <span class="cov0" title="0">d.printOutUC.Println(color.RedString("The dotfiles Brewfile and the currently installed package are different."))
        d.printOutUC.PrintMdf(`
### Update Brewfile

diff:
` + diffNames + `

What will you do to resolve the diff?

1. update the Brewfile with the currently installed packages
2. run ` + "`brew bundlecleanup`" + `
3. do nothing
4. exit
`)
        d.printOutUC.Print("What do you run? [1-4]: ")

        return d.updateBrewfile(brewPath, brewTmpPath)</span>
}

func (d *DepsUsecaseImpl) updateBrewfile(brewPath string, brewTmpPath string) error <span class="cov0" title="0">{
        scanner := bufio.NewScanner(os.Stdin)
        if scanner.Scan() </span><span class="cov0" title="0">{
                switch strings.TrimSpace(scanner.Text()) </span>{
                case "1":<span class="cov0" title="0">
                        d.printOutUC.PrintMdf("#### Open Brewfile with code\n")

                        if err := d.resolveBrewDiff(brewPath, brewTmpPath); err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "deps usecase: failed to resolve Brewfile diff")
                        }</span>

                        <span class="cov0" title="0">d.printOutUC.Println("Running `brew bundle cleanup`")

                        if err := d.brewUC.CleanupBrewBundle(brewPath, true); err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "deps usecase: failed to run brew bundle cleanup")
                        }</span>

                case "2":<span class="cov0" title="0">
                        d.printOutUC.Println("Running `brew bundle cleanup`")

                        if err := d.brewUC.CleanupBrewBundle(brewPath, true); err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "deps usecase: failed to run brew bundle cleanup")
                        }</span>
                case "3":<span class="cov0" title="0">
                        d.printOutUC.Println("Do nothing")</span>
                default:<span class="cov0" title="0">
                        d.printOutUC.Println("Exit")

                        if err := d.Finish(); err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "deps usecase: failed to finish")
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

//nolint:funlen
func (d *DepsUsecaseImpl) resolveBrewDiff(brewPath string, brewTmpPath string) error <span class="cov0" title="0">{
        diffBundles, diffTmpBundles, err := d.brewUC.CheckDiffBrewBundle(brewPath, brewTmpPath)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "deps usecase: failed to check diff Brewfile")
        }</span>

        <span class="cov0" title="0">ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
        endFlag := false

        defer func() </span><span class="cov0" title="0">{
                endFlag = true

                stop()
        }</span>()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                &lt;-ctx.Done()

                if endFlag </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">d.printOutUC.PrintMdf(`
&gt; [!WARNING]
&gt; The Brewfile changes have been discarded.
`)

                d.gitInfrastructure.SetGitDir(filepath.Dir(brewPath))

                if err := d.gitInfrastructure.CheckoutFile(brewPath); err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
        }()

        <span class="cov0" title="0">bundles, err := d.brewInfrastructure.ReadBrewBundle(brewPath)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "deps usecase: failed to read Brewfile")
        }</span>

        <span class="cov0" title="0">if err = d.brewInfrastructure.WriteBrewBundle(brewPath, mergeDiff(bundles, diffTmpBundles, diffBundles)); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "deps usecase: failed to write Brewfile")
        }</span>

        <span class="cov0" title="0">d.printOutUC.PrintMdf(`
&gt; [!NOTE]
&gt; If you do not want to change it, do a process kill (ctrl + c)
`)

        d.resolveBrewDiffWithEditorCount = 0
        if err := d.resolveBrewDiffWithEditor(ctx, brewPath); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "deps usecase: failed to resolve Brewfile diff with editor")
        }</span>

        <span class="cov0" title="0">bundles, err = d.brewInfrastructure.ReadBrewBundle(brewPath)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "deps usecase: failed to read Brewfile")
        }</span>

        <span class="cov0" title="0">if err := d.brewInfrastructure.WriteBrewBundle(brewPath, bundles); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "deps usecase: failed to write Brewfile")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (d *DepsUsecaseImpl) resolveBrewDiffWithEditor(ctx context.Context, brewPath string) error <span class="cov0" title="0">{
        d.resolveBrewDiffWithEditorCount++

        if d.resolveBrewDiffWithEditorCount &gt; resolveBrewDiffWithEditorMaxCount </span><span class="cov0" title="0">{
                d.printOutUC.PrintMdf(`
&gt; [!CAUTION]
&gt; Abort because brewfile was not updated
`)

                return errResolveBrewDiffWithEditorMaxCount
        }</span>

        <span class="cov0" title="0">d.gitInfrastructure.SetGitDir(filepath.Dir(brewPath))

        if err := d.gitInfrastructure.GitDifftool(
                ctx,
                *d.printOutUC.GetOut(),
                *d.printOutUC.GetError(),
                brewPath,
        ); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "deps usecase: failed to open with code")
        }</span>

        <span class="cov0" title="0">if data, err := d.fileInfrastructure.ReadFile(brewPath); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "deps usecase: failed to read Brewfile")
        }</span> else<span class="cov0" title="0"> if strings.Contains(string(data), "# "+dofyBrewCategory) </span><span class="cov0" title="0">{
                d.printOutUC.PrintMdf(`
&gt; [!CAUTION]
&gt; Update your brewfile
`)

                err := d.resolveBrewDiffWithEditor(ctx, brewPath)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "deps usecase: failed to resolve Brewfile diff with editor")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func mergeDiff(
        base []domain.BrewBundle,
        add []domain.BrewBundle,
        sub []domain.BrewBundle,
) []domain.BrewBundle <span class="cov0" title="0">{
        for _, diff := range add </span><span class="cov0" title="0">{
                diff.Categories = []string{dofyBrewCategory}
                base = append(base, diff)
        }</span>

        <span class="cov0" title="0">for _, diff := range sub </span><span class="cov0" title="0">{
                for i, bundle := range base </span><span class="cov0" title="0">{
                        if bundle.Name == diff.Name </span><span class="cov0" title="0">{
                                base = append(base[:i], base[i+1:]...)
                        }</span>
                }
        }

        <span class="cov0" title="0">return base</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package usecase

import (
        "fmt"
        "io"
        "os"
        "reflect"

        "github.com/shiron-dev/dotfiles/scripts/dofy/internal/domain"
        "github.com/shiron-dev/dotfiles/scripts/dofy/internal/infrastructure"
)

type PrintOutUsecase interface {
        PrintMdf(format string, a ...interface{})
        Println(str string)
        Print(str string)
        PrintObj(obj interface{})
        SetLogOutput() *os.File

        GetOut() *io.Writer
        GetError() *io.Writer
}

type PrintOutUsecaseImpl struct {
        printOutInfrastructure infrastructure.PrintOutInfrastructure
}

func NewPrintOutUsecase(printOutInfrastructure infrastructure.PrintOutInfrastructure) *PrintOutUsecaseImpl <span class="cov0" title="0">{
        return &amp;PrintOutUsecaseImpl{
                printOutInfrastructure: printOutInfrastructure,
        }
}</span>

func (p *PrintOutUsecaseImpl) PrintMdf(format string, a ...interface{}) <span class="cov0" title="0">{
        str := fmt.Sprintf(format, a...)

        for _, printer := range domain.GetMdPrinter() </span><span class="cov0" title="0">{
                if printer.Printer != nil </span><span class="cov0" title="0">{
                        str = printer.Printer(str)
                }</span> else<span class="cov0" title="0"> {
                        str = printer.Reg.ReplaceAllStringFunc(str, func(s string) string </span><span class="cov0" title="0">{
                                return printer.Col.SprintFunc()(s)
                        }</span>)
                }
        }

        <span class="cov0" title="0">p.Println(str)</span>
}

func (p *PrintOutUsecaseImpl) PrintObj(obj interface{}) <span class="cov0" title="0">{
        t := reflect.TypeOf(obj)
        v := reflect.ValueOf(obj)

        for i := range t.NumField() </span><span class="cov0" title="0">{
                field := t.Field(i)
                p.Println(field.Name + ": " + v.Field(i).String())
        }</span>
}

func (p *PrintOutUsecaseImpl) Println(str string) <span class="cov0" title="0">{
        p.printOutInfrastructure.Print(str + "\n")
}</span>

func (p *PrintOutUsecaseImpl) Print(str string) <span class="cov0" title="0">{
        p.printOutInfrastructure.Print(str)
}</span>

const filePermission = 0o666

func (p *PrintOutUsecaseImpl) SetLogOutput() *os.File <span class="cov0" title="0">{
        logFile, err := os.OpenFile("./dotfiles.log", os.O_APPEND|os.O_CREATE|os.O_WRONLY, filePermission)
        if err != nil </span><span class="cov0" title="0">{
                panic("cannot open ./dotfiles.log:" + err.Error())</span>
        }

        <span class="cov0" title="0">p.printOutInfrastructure.SetLogOutput(logFile)

        return logFile</span>
}

func (p *PrintOutUsecaseImpl) GetOut() *io.Writer <span class="cov0" title="0">{
        return p.printOutInfrastructure.GetOut()
}</span>

func (p *PrintOutUsecaseImpl) GetError() *io.Writer <span class="cov0" title="0">{
        return p.printOutInfrastructure.GetError()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
